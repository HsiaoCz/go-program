rpc:远程过程调用

区别于本地过程调用

```go
package main

import "fmt"

func main(){
// 调用本地函数
a:=10
b:=20
ret:=add(a,b)
fmt.Println(ret)
}

func add(s,a int)int{
    return a+b
}

```

将这个程序编译之后运行，会输出结果30
我们在main函数里调用add函数，有这样几个步骤
1.将变量a和b的值分别压入堆栈上
2.执行add函数，从堆栈中获取到a和b的值，并将它们分配给x和y
3.计算x+y的值并且将其值保存到堆栈中
4.退出add函数并将x+y的值赋值给ret

rpc调用：
本地过程调用发生在同一个进程中，定义函数的代码和调用函数的代码是共享一个内存空间的，所以调用能够正常执行

但是我们无法直接调用在另一个服务器上的add函数，它们在两个程序中，内存空间物理隔离
rpc：远程过程调用就是为了解决这类问题
要实现rpc需要实现以下三个问题:
1.如何确定要执行的函数?
在本地调用的过程中，函数主体是通过函数指针函数指定，调用add函数，编译器通过函数指针函数自动确定add函数在内存中的位置。
在rpc中没办法通过函数指针函数确定函数在内存中的位置，所以调用双方需要维护一个{function--->ID}的映射表，用来确定调用正确的函数

2.如何表达参数？
本地过程调用的参数传递是通过内存堆栈完成的，远程调用传递参数和返回参数需要在传递期间序列化并转换成字节流

3.如何实现网络传输
函数调用方和被调用方通常是通过网络连接的